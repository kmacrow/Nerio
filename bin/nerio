#!/usr/bin/env node

/**
 * Nerio implements an event-driven JavaScript parser
 * and two modules that inspect the AST for 
 * restricted features and function calls.
 *
**/

var fs = require('fs');
var EventEmitter = require('events').EventEmitter;
var esprima = require('esprima');
var escodegen = require('escodegen');
var esmangle  = require('esmangle');
var argv = require('optimist').argv;

// global internal event bus
var events = new EventEmitter();

// global internal errors 
var errors = [];


// take a file name from the command line
if( argv._.length ) {

    fs.readFile(argv._[0], 'utf-8', function(err, code) {
        
        if( err ) {
            return console.log( err );
        }

        main( code );
    });

// or, read code from stdin...
} else {

    var code = '';

    process.stdin.resume();
    process.stdin.setEncoding('utf-8');
    process.stdin.on('data', function(buf) { code += buf; });
    process.stdin.on('end', function() {

        main( code );
    
    });
}

function main(code) {
    var passed = check(code);
    process.exit(passed ? 0 : 1);
}


/**
 * MODULE: language features
 *
**/
events.on('Identifier', function(name, line, col) {
    
    if ( name == 'eval' ) {

        errors.push(['Illegal reference to eval()', line, col]);
    
    }

});

/** 
 * MODULE: browser APIs
 *
**/
events.on('Identifier', function(name, line, col) {
    
    if( [        'window', 'document', 
             'setTimeout', 'setInterval', 
          'clearInterval', 'WebWorker',
         'XMLHttpRequest', 'localStorage',
         'sessionStorage', 'IndexedDB'].indexOf(name) != -1 ) {

        errors.push(['Illegal reference to "' + name + '"', line, col]);
    }

});

/**
 * Push code through all available checks
 *
 * code - a string containing JavaScript
**/
function check(code) 
{

    // initial AST (abstract syntax tree)
    var ast = esprima.parse(code, {loc: true});

    // compressed/simplified AST
    // ast = esmangle.optimize(ast, null);

    // reset errors
    errors = [];

    for(var i = 0; i < ast.body.length; i++ ) {
        
        check_ast(ast.body[i]);

    }    


    if ( errors.length ) {
        console.log('Failed:');
        for( var i = 0; i < errors.length; i++ ) {
            var err = errors[i];
            console.log( err[0] + ' at ' + err[1] + ':' + err[2] );
        }
        return false;
    }

    console.log('Passed.');
    return true;

}

/**
 * Recursively walk AST subtree emitting events at nodes
 * 
 * ast - the ast subtree
**/
function check_ast(ast) {

    switch(ast.type) {

        case 'Identifier':
            events.emit('Identifier', 
                         ast.name, 
                         ast.loc.start.line,
                         ast.loc.start.column);
            break;

        case 'BinaryExpression':
        case 'LogicalExpression':
        case 'AssignmentExpression':

            events.emit(ast.type, 
                        ast.left, ast.right, 
                        ast.left.loc.start.line,
                        ast.left.loc.start.column);

            check_ast(ast.left);
            check_ast(ast.right);

            break;

        case 'MemberExpression':

            var computed = ast.computed;

            events.emit('MemberExpression',
                        ast.object, ast.property, computed,
                        ast.object.loc.start.line,
                        ast.object.loc.start.column);

            check_ast(ast.object);
            check_ast(ast.property);
            
            break;

        case 'NewExpression':
        case 'CallExpression':
    
            switch(ast.callee.type) {
                case 'Identifier':
                case 'MemberExpression':
                case 'FunctionExpression':

                    check_ast(ast.callee);    
                    break;
            }

            events.emit(ast.type,
                        ast.callee, ast.arguments,
                        ast.loc.start.line,
                        ast.loc.start.column);
            
            for( var i = 0; i < ast.arguments.length; i++ ) {
                check_ast( ast.arguments[i] );
            }

            break;

        case 'ExpressionStatement':

            check_ast(ast.expression);

            break;

        case 'FunctionExpression':

            check_ast(ast.body);

            break;

        case 'ReturnStatement':

            events.emit('ReturnStatement',
                        ast.argument,
                        ast.loc.start.line,
                        ast.loc.start.column);

            check_ast(ast.argument);

            break;

        case 'VariableDeclaration':
            
            for(var i = 0; i < ast.declarations.length; i++) {

                events.emit('VariableDeclaration',
                            ast.declarations[i].id,
                            ast.declarations[i].init,
                            ast.loc.start.line,
                            ast.loc.start.column);

                check_ast( ast.declarations[i].init );
            }

            break;

        case 'IfStatement':
        case 'ConditionalExpression':
            
            events.emit(ast.type,
                        ast.test,
                        ast.loc.start.line,
                        ast.loc.start.column);

            check_ast(ast.test);
            check_ast(ast.consequent);

            if( ast.alternate ) {
                check_ast(ast.alternate);
            }

            break;

        case 'BlockStatement':

            for( var i = 0; i < ast.body.length; i++ ) {
                check_ast(ast.body[i]);
            }

            break;

        default:
            // unknown AST node type...
            break;
    }

}

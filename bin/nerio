#!/usr/bin/env node

var fs = require('fs');
var esprima = require('esprima');
var escodegen = require('escodegen');
var esmangle  = require('esmangle');
var argv = require('optimist').argv;


// take a file name from the command line
if( argv._.length ) {

    fs.readFile(argv._[0], 'utf-8', function(err, code) {
        
        if( err ) {
            return console.log( err );
        }

        check( code );
    });

// or, read code from stdin...
} else {

    var code = '';

    process.stdin.resume();
    process.stdin.setEncoding('utf-8');
    process.stdin.on('data', function(buf) { code += buf; });
    process.stdin.on('end', function() {

        check( code );
    
    });
}

/**
 * Push code through all available checks
 *
 * code - a string containing javascript
**/
function check(code) 
{

    // initial AST (abstract syntax tree)
    var ast = esprima.parse(code, {loc: true}),

    // compressed/simplified AST
    compressed = esmangle.optimize(ast, null);

    var passed = true, errors = [];

    var checks = {
        'EVAL': check_eval
        // add others here...
    };

    for(var i = 0; i < compressed.body.length; i++ ) {
        for(var chk in checks) {

            var result = checks[chk]( compressed.body[i] );
            
            if( !result.success ) {
                errors = errors.concat( result.errors.map(function(e){
                    return chk + ': ' + e;
                }) );
            }

        }
    }    


    if ( !passed ) {
        console.log('Errors:');
        for( var i = 0; i < errors.length; i++ ) {
            console.log( errors[i] );
        }
        process.exit(1);
    }

    console.log('Passed.');
    process.exit(0);

}

/**
 * Recursively check ast subtree for calls to eval
 * 
 * ast - the ast subtree
**/
function check_eval(ast) {

    return {success: true, errors: []};

}

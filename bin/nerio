#!/usr/bin/env node

var fs = require('fs');
var esprima = require('esprima');
var escodegen = require('escodegen');
var esmangle  = require('esmangle');
var argv = require('optimist').argv;


// take a file name from the command line
if( argv._.length ) {

    fs.readFile(argv._[0], 'utf-8', function(err, code) {
        
        if( err ) {
            return console.log( err );
        }

        main( code );
    });

// or, read code from stdin...
} else {

    var code = '';

    process.stdin.resume();
    process.stdin.setEncoding('utf-8');
    process.stdin.on('data', function(buf) { code += buf; });
    process.stdin.on('end', function() {

        main( code );
    
    });
}

function main(code) {
    var passed = check(code);
    process.exit(passed ? 0 : 1);
}

/**
 * Push code through all available checks
 *
 * code - a string containing javascript
**/
function check(code) 
{

    // initial AST (abstract syntax tree)
    var ast = esprima.parse(code, {loc: true}),

    // compressed/simplified AST
    compressed = esmangle.optimize(ast, null);

    var errors = [];

    var checks = {
        'EVAL': check_eval
        // add others here...
    };

    for(var i = 0; i < compressed.body.length; i++ ) {
        for(var chk in checks) {

            var result = checks[chk]( compressed.body[i] );
            
            if( !result.success ) {
                errors = errors.concat( result.errors.map(function(e){
                    return [chk + ': ' + e[0], e[1], e[2]];
                }) );
            }

        }
    }    


    if ( errors.length ) {
        console.log('Failed:');
        for( var i = 0; i < errors.length; i++ ) {
            var err = errors[i];
            console.log( err[0] + ' at ' + err[1] + ':' + err[2] );
        }
        return false;
    }

    console.log('Passed.');
    return true;

}

/**
 * Recursively check ast subtree for calls to eval
 * 
 * ast - the ast subtree
**/
function check_eval(ast) {

    var result = arguments[1] || {success: true, errors: []};


    switch(ast.type) {
        case 'ExpressionStatement':
            if(ast.expression.type == 'CallExpression') {
                if( ast.expression.callee.type == 'Identifier' 
                    && ast.expression.callee.name == 'eval') {
                    result.success = false;
                    result.errors.push(
                        ['Explicit call to eval()', 
                         ast.expression.callee.loc.start.line,
                         ast.expression.callee.loc.start.column]);
                }
            }
        break;
        case 'VariableDeclaration':
            for(var i = 0; i < ast.declarations.length; i++) {
                var d = ast.declarations[i];
                if( d.init.type == 'CallExpression' ){
                    if( d.init.callee.type == 'Identifier' 
                        && d.init.callee.name == 'eval' ) {
                        
                        result.success = false;
                        result.errors.push(
                            ['Assignment to result of eval()', 
                             d.init.callee.loc.start.line,
                             d.init.callee.loc.start.column]);
                    }
                }
                if( d.init.type == 'Identifier' && d.init.name == 'eval' ) {
                    result.success = false;
                    result.errors.push(
                            ['Assignment to eval function', 
                             d.init.loc.start.line,
                             d.init.loc.start.column]);
                }
            }
            break;
        case 'IfStatement':
            break;

        case 'BlockStatement':
            break;
    }
    
    return result;

}
